import*as Host from"../host/host.js";import*as Platform from"../platform/platform.js";import{Action}from"./Action.js";import{ActionRegistry}from"./ActionRegistry.js";import{Context}from"./Context.js";import{Dialog}from"./Dialog.js";import{Descriptor,KeyboardShortcut,Modifiers,Type}from"./KeyboardShortcut.js";import{isEditing}from"./UIUtils.js";export class ShortcutRegistry{constructor(t){this._actionRegistry=t,this._keyToShortcut=new Platform.Multimap,this._actionToShortcut=new Platform.Multimap,this._keyMap=new ShortcutTreeNode(0,0),this._activePrefixKey=null,this._activePrefixTimeout=null,this._consumePrefix=null,this._registerBindings()}_applicableActions(t,e={}){let i=[];const o=(this._activePrefixKey||this._keyMap).getNode(t);o&&(i=o.actions());const r=this._actionRegistry.applicableActions(i,self.UI.context);if(o)for(const t of Object.keys(e))if(o.actions().indexOf(t)>=0){const e=this._actionRegistry.action(t);e&&r.push(e)}return r}shortcutsForAction(t){return[...this._actionToShortcut.get(t)]}globalShortcutKeys(){const t=[];for(const e of this._keyMap.chords().values()){const i=e.actions();(this._actionRegistry.applicableActions(i,new Context).length||e.hasChords())&&t.push(e.key())}return t}shortcutDescriptorsForAction(t){return[...this._actionToShortcut.get(t)].map(t=>t.descriptors[0])}keysForActions(t){const e=t.flatMap(t=>[...this._actionToShortcut.get(t)].flatMap(t=>t.descriptors.map(t=>t.key)));return[...new Set(e)]}shortcutTitleForAction(t){const e=this._actionToShortcut.get(t);if(e.size)return e.firstValue().title()}handleShortcut(t,e){this.handleKey(KeyboardShortcut.makeKeyFromEvent(t),t.key,t,e)}addShortcutListener(t,e){const i=new ShortcutTreeNode(0,0);Object.keys(e).flatMap(t=>[...this._actionToShortcut.get(t)]).forEach(t=>{i.addKeyMapping(t.descriptors.map(t=>t.key),t.action)}),t.addEventListener("keydown",t=>{const o=KeyboardShortcut.makeKeyFromEvent(t);let r=i;this._activePrefixKey&&(r=r.getNode(this._activePrefixKey.key()),!r)||r.getNode(o)&&this.handleShortcut(t,e)})}async handleKey(t,e,i,o){const r=t>>8;if(!o&&(function(){if(!i||!isEditing()||/^F\d+|Control|Shift|Alt|Meta|Escape|Win|U\+001B$/.test(e))return!1;if(!r)return!0;const o=Modifiers;if(Host.Platform.isMac()){if(KeyboardShortcut.makeKey("z",o.Meta)===t)return!0;if(KeyboardShortcut.makeKey("z",o.Meta|o.Shift)===t)return!0}else{if(KeyboardShortcut.makeKey("z",o.Ctrl)===t)return!0;if(KeyboardShortcut.makeKey("y",o.Ctrl)===t)return!0;if(!Host.Platform.isWin()&&KeyboardShortcut.makeKey("z",o.Ctrl|o.Shift)===t)return!0}if((r&(o.Ctrl|o.Alt))==(o.Ctrl|o.Alt))return Host.Platform.isWin();return!n(o.Ctrl)&&!n(o.Alt)&&!n(o.Meta)}()||Dialog.hasInstance())||KeyboardShortcut.isModifier(KeyboardShortcut.keyCodeAndModifiersFromKey(t).keyCode))return;if(this._activePrefixTimeout){clearTimeout(this._activePrefixTimeout);const t=await c.call(this);if(this._activePrefixKey=null,this._activePrefixTimeout=null,t)return;this._consumePrefix&&await this._consumePrefix()}const s=this._keyMap.getNode(t);function n(t){return!!(r&t)}async function c(){const e=this._applicableActions(t,o);if(!e.length)return!1;i&&i.consume(!0);for(const t of e){let e;if(o&&o[t.id()]&&(e=await o[t.id()]()),o||(e=await t.execute()),e)return Host.userMetrics.keyboardShortcutFired(t.id()),!0}return!1}s&&s.hasChords()?(i&&i.consume(!0),this._activePrefixKey=s,this._consumePrefix=async()=>{this._activePrefixKey=null,this._activePrefixTimeout=null,await c.call(this)},this._activePrefixTimeout=setTimeout(this._consumePrefix,KeyTimeout)):await c.call(this)}_registerShortcut(t){this._actionToShortcut.set(t.action,t),this._keyMap.addKeyMapping(t.descriptors.map(t=>t.key),t.action)}_registerBindings(){function t(t){if(!t)return!0;const e=t.split(",");let i=!1;const o=Host.Platform.platform();for(let t=0;!i&&t<e.length;++t)i=e[t]===o;return i}self.runtime.extensions("action").forEach((function(e){const i=e.descriptor(),o=i.bindings;for(let e=0;o&&e<o.length;++e){if(!t(o[e].platform))continue;const r=o[e].shortcut.split(/\s+/).map(KeyboardShortcut.makeDescriptorFromBindingShortcut);r.length>0&&this._registerShortcut(new KeyboardShortcut(r,i.actionId,Type.DefaultShortcut))}}),this)}}export class ShortcutTreeNode{constructor(t,e=0){this._key=t,this._actions=[],this._chords=new Map,this._depth=e}addAction(t){this._actions.push(t)}key(){return this._key}chords(){return this._chords}hasChords(){return this._chords.size>0}addKeyMapping(t,e){if(!(t.length<this._depth))if(t.length===this._depth)this.addAction(e);else{const i=t[this._depth];this._chords.has(i)||this._chords.set(i,new ShortcutTreeNode(i,this._depth+1)),this._chords.get(i).addKeyMapping(t,e)}}getNode(t){return this._chords.get(t)||null}actions(){return this._actions}}export class ForwardedShortcut{}ForwardedShortcut.instance=new ForwardedShortcut;export const KeyTimeout=1e3;