import*as Common from"../common/common.js";import*as Host from"../host/host.js";import*as ProtocolClient from"../protocol_client/protocol_client.js";import{ParallelConnection}from"./Connections.js";import{Capability,Events,SDKModel,Target,TargetManager,Type}from"./SDKModel.js";let _attachCallback,_lastAnonymousTargetId=0;export class ChildTargetManager extends SDKModel{constructor(t){super(t),this._targetManager=t.targetManager(),this._parentTarget=t,this._targetAgent=t.targetAgent(),this._targetInfos=new Map,this._childTargets=new Map,this._parallelConnections=new Map,this._parentTargetId=null,t.registerTargetDispatcher(this),this._targetAgent.invoke_setAutoAttach({autoAttach:!0,waitForDebuggerOnStart:!0,flatten:!0}),t.parentTarget()||Host.InspectorFrontendHost.isUnderTest()||(this._targetAgent.setDiscoverTargets(!0),this._targetAgent.setRemoteLocations([{host:"localhost",port:9229}]))}static install(t){_attachCallback=t,SDKModel.register(ChildTargetManager,Capability.Target,!0)}suspendModel(){return this._targetAgent.invoke_setAutoAttach({autoAttach:!0,waitForDebuggerOnStart:!1,flatten:!0})}resumeModel(){return this._targetAgent.invoke_setAutoAttach({autoAttach:!0,waitForDebuggerOnStart:!0,flatten:!0})}dispose(){for(const t of this._childTargets.keys())this.detachedFromTarget(t,void 0)}targetCreated(t){this._targetInfos.set(t.targetId,t),this._fireAvailableTargetsChanged()}targetInfoChanged(t){this._targetInfos.set(t.targetId,t),this._fireAvailableTargetsChanged()}targetDestroyed(t){this._targetInfos.delete(t),this._fireAvailableTargetsChanged()}targetCrashed(t,e,a){}_fireAvailableTargetsChanged(){TargetManager.instance().dispatchEventToListeners(Events.AvailableTargetsChanged,[...this._targetInfos.values()])}async _getParentTargetId(){return this._parentTargetId||(this._parentTargetId=(await this._parentTarget.targetAgent().getTargetInfo()).targetId),this._parentTargetId}attachedToTarget(t,e,a){if(this._parentTargetId===e.targetId)return;let r="";if("worker"===e.type&&e.title&&e.title!==e.url)r=e.title;else if("iframe"!==e.type){const t=Common.ParsedURL.ParsedURL.fromString(e.url);r=t?t.lastPathComponentWithFragment():"#"+ ++_lastAnonymousTargetId}let n=Type.Browser;"iframe"===e.type||"page"===e.type?n=Type.Frame:"worker"===e.type?n=Type.Worker:"service_worker"===e.type&&(n=Type.ServiceWorker);const s=this._targetManager.createTarget(e.targetId,r,n,this._parentTarget,t);this._childTargets.set(t,s),_attachCallback?_attachCallback({target:s,waitingForDebugger:a}).then(()=>{s.runtimeAgent().runIfWaitingForDebugger()}):s.runtimeAgent().runIfWaitingForDebugger()}detachedFromTarget(t,e){this._parallelConnections.has(t)?this._parallelConnections.delete(t):(this._childTargets.get(t).dispose("target terminated"),this._childTargets.delete(t))}receivedMessageFromTarget(t,e,a){}async createParallelConnection(t){const e=await this._getParentTargetId(),{connection:a,sessionId:r}=await this._createParallelConnectionAndSessionForTarget(this._parentTarget,e);return a.setOnMessage(t),this._parallelConnections.set(r,a),a}async _createParallelConnectionAndSessionForTarget(t,e){const a=t.targetAgent(),r=t.router(),n=await a.attachToTarget(e,!0),s=new ParallelConnection(r.connection(),n);return r.registerSession(t,n,s),s.setOnDisconnect(()=>{a.detachFromTarget(n),r.unregisterSession(n)}),{connection:s,sessionId:n}}}