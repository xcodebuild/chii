import*as Common from"../common/common.js";import*as ProtocolClient from"../protocol_client/protocol_client.js";import*as TextUtils from"../text_utils/text_utils.js";import{DebuggerModel,Location}from"./DebuggerModel.js";import{ResourceTreeModel}from"./ResourceTreeModel.js";import{ExecutionContext}from"./RuntimeModel.js";export class Script{constructor(t,e,r,i,s,o,n,c,a,u,d,l,h,m,p,g,f){this.debuggerModel=t,this.scriptId=e,this.sourceURL=r,this.lineOffset=i,this.columnOffset=s,this.endLine=o,this.endColumn=n,this.executionContextId=c,this.hash=a,this._isContentScript=u,this._isLiveEdit=d,this.sourceMapURL=l,this.hasSourceURL=h,this.contentLength=m,this._originalContentProvider=null,this._originalSource=null,this.originStackTrace=p,this._codeOffset=g,this._language=f,this._lineMap=null}static _trimSourceURLComment(t){let e=t.lastIndexOf("//# sourceURL=");if(-1===e&&(e=t.lastIndexOf("//@ sourceURL="),-1===e))return t;const r=t.lastIndexOf("\n",e);if(-1===r)return t;return t.substr(r+1).match(sourceURLRegex)?t.substr(0,r):t}isContentScript(){return this._isContentScript}codeOffset(){return this._codeOffset}isWasm(){return this._language===Protocol.Debugger.ScriptLanguage.WebAssembly}hasWasmDisassembly(){return!!this._lineMap&&!this.sourceMapURL}executionContext(){return this.debuggerModel.runtimeModel().executionContext(this.executionContextId)}isLiveEdit(){return this._isLiveEdit}contentURL(){return this.sourceURL}contentType(){return Common.ResourceType.resourceTypes.Script}contentEncoded(){return Promise.resolve(!1)}async requestContent(){if(this._source)return{content:this._source,isEncoded:!1};if(!this.scriptId)return{error:ls`Script removed or deleted.`,isEncoded:!1};try{const t=await this.debuggerModel.target().debuggerAgent().invoke_getScriptSource({scriptId:this.scriptId}),e=t.scriptSource;if(e)this.hasSourceURL?this._source=Script._trimSourceURLComment(e):this._source=e;else if(this._source="",t.bytecode){const e=new Common.Worker.WorkerWrapper("wasmparser_worker_entrypoint"),r=new Promise((function(t,r){e.onmessage=t,e.onerror=r}));e.postMessage({method:"disassemble",params:{content:t.bytecode}});const i=await r;this._source=i.data.source,this._lineMap=i.data.offsets,this.endLine=this._lineMap.length}return null===this._originalSource&&(this._originalSource=this._source),{content:this._source,isEncoded:!1}}catch(t){return{error:ls`Unable to fetch script source.`,isEncoded:!1}}}async getWasmBytecode(){const t=await this.debuggerModel.target().debuggerAgent().getWasmBytecode(this.scriptId);return(await fetch("data:application/wasm;base64,"+t)).arrayBuffer()}originalContentProvider(){if(!this._originalContentProvider){const t=()=>this.requestContent().then(()=>({content:this._originalSource,isEncoded:!1}));this._originalContentProvider=new TextUtils.StaticContentProvider.StaticContentProvider(this.contentURL(),this.contentType(),t)}return this._originalContentProvider}async searchInContent(t,e,r){if(!this.scriptId)return[];return(await this.debuggerModel.target().debuggerAgent().searchInContent(this.scriptId,t,e,r)||[]).map(t=>new TextUtils.ContentProvider.SearchMatch(t.lineNumber,t.lineContent))}_appendSourceURLCommentIfNeeded(t){return this.hasSourceURL?t+"\n //# sourceURL="+this.sourceURL:t}async editSource(t,e){if(t=Script._trimSourceURLComment(t),t=this._appendSourceURLCommentIfNeeded(t),!this.scriptId)return void e("Script failed to parse");if(await this.requestContent(),this._source===t)return void e(null);const r=await this.debuggerModel.target().debuggerAgent().invoke_setScriptSource({scriptId:this.scriptId,scriptSource:t});r[ProtocolClient.InspectorBackend.ProtocolError]||r.exceptionDetails||(this._source=t);const i=!!r.stackChanged;e(r[ProtocolClient.InspectorBackend.ProtocolError],r.exceptionDetails,r.callFrames,r.asyncStackTrace,r.asyncStackTraceId,i)}rawLocation(t,e){return this.containsLocation(t,e)?new Location(this.debuggerModel,this.scriptId,t,e):null}wasmByteLocation(t){return t<this._lineMap.length?new Location(this.debuggerModel,this.scriptId,0,this._lineMap[t]):null}wasmDisassemblyLine(t){let e=0;for(;e<this._lineMap.length&&t>this._lineMap[e];)e++;return e}toRelativeLocation(t){console.assert(t.scriptId===this.scriptId,"`toRelativeLocation` must be used with location of the same script");const e=t.lineNumber-this.lineOffset;return[e,(t.columnNumber||0)-(0===e?this.columnOffset:0)]}isInlineScript(){const t=!this.lineOffset&&!this.columnOffset;return!this.isWasm()&&!!this.sourceURL&&!t}isAnonymousScript(){return!this.sourceURL}isInlineScriptWithSourceURL(){return!!this.hasSourceURL&&this.isInlineScript()}async setBlackboxedRanges(t){return!(await this.debuggerModel.target().debuggerAgent().invoke_setBlackboxedRanges({scriptId:this.scriptId,positions:t}))[ProtocolClient.InspectorBackend.ProtocolError]}containsLocation(t,e){const r=t===this.lineOffset&&e>=this.columnOffset||t>this.lineOffset,i=t<this.endLine||t===this.endLine&&e<=this.endColumn;return r&&i}get frameId(){return"string"!=typeof this[frameIdSymbol]&&(this[frameIdSymbol]=frameIdForScript(this)),this[frameIdSymbol]}}const frameIdSymbol=Symbol("frameid");function frameIdForScript(t){const e=t.executionContext();if(e)return e.frameId||"";const r=t.debuggerModel.target().model(ResourceTreeModel);return r&&r.mainFrame?r.mainFrame.id:""}export const sourceURLRegex=/^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/;